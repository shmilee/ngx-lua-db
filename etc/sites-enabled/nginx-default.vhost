map $http_user_agent $ignore_ua {
    default         0;
    "~Pingdom.*"    1;
    "~Monit/5.*"    1;
}

lua_package_path "/srv/etc/lualib/?.lua;;";

server {
    listen       80 default;
    server_name  api.jxswhg.com;
    charset   utf-8;
    location / {
        if ($ignore_ua) {
            access_log off;
            return 200;
        }
        default_type 'text/plain';
        content_by_lua_block {
            ngx.say('Hello, world!')
        }
    }
    error_page   500 502 503 504  /50x.html;
    location = /50x.html {
        root   /usr/share/mynginx/html;
    }
    location ~ /\.ht {
        deny  all;
    }
    location /status {   
        stub_status on;   
        access_log on;
    }
    location /monit/ {
        allow 172.17.0.0/16;
        deny  all;
        rewrite ^/monit/(.*) /$1 break;
        proxy_ignore_client_abort on;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header Host $http_host;
        proxy_set_header X-NginX-Proxy true;
        proxy_pass         http://127.0.0.1:2812;
        proxy_redirect off;
        proxy_http_version 1.1;
        proxy_set_header Upgrade $http_upgrade;
        proxy_set_header Connection "upgrade";
        if ($request_uri ~ ^/favicon.ico$) {
            access_log off;
        }
    }

    # test redis
    location /redis {
            default_type 'text/plain';
            content_by_lua_block {
                local redis = require "resty.redis"
                local red = redis:new()

                red:set_timeout(1000) -- 1 sec

                local ok, err = red:connect("127.0.0.1", 6379)
                if not ok then
                    ngx.say("failed to connect: ", err)
                    return
                end

                ngx.say("connect redis")

                ok, err = red:set("dog", "an animal")
                if not ok then
                    ngx.say("failed to set dog: ", err)
                    return
                end

                ngx.say("set result: ", ok)

                local res, err = red:get("dog")
                if not res then
                    ngx.say("failed to get dog: ", err)
                    return
                end

                if res == ngx.null then
                    ngx.say("dog not found.")
                    return
                end

                ngx.say("dog: ", res)

                red:set("cat", "Marry")
                red:init_pipeline()
                red:set("horse", "Bob")
                red:get("cat")
                red:get("horse")
                local results, err = red:commit_pipeline()
                if not results then
                    ngx.say("failed to commit the pipelined requests: ", err)
                    return
                end

                for i, res in ipairs(results) do
                    if type(res) == "table" then
                        if res[1] == false then
                            ngx.say("failed to run command ", i, ": ", res[2])
                        else
                            -- process the table value
                            for j, r in ipairs(res) do
                                ngx.say('tba: ', i, ' ', j, ' ', r)
                            end
                        end
                    else
                        ngx.say(i, ' ', res)
                        -- process the scalar value
                    end
                end

                -- put it into the connection pool of size 100,
                -- with 10 seconds max idle time
                local ok, err = red:set_keepalive(10000, 100)
                if not ok then
                    ngx.say("failed to set keepalive: ", err)
                    return
                end
            }
    }
    # mysql
    location /mysql {
        default_type 'text/plain';
        content_by_lua_block {
            local dbact = require("cclua.activity")
            local conn, err = dbact:new('set')
            if not conn then
                ngx.say('error: ', err)
                return
            else
                ngx.say('Get connect!', err)
            end
            local res = conn:add_activity({
                title='活动名称1',
                author='shmilee',
                a_host='嘉兴文化馆',
                contact='电话 12112323123',
                submission_datetime='2018-07-20 13:34:06',
                start_datetime='2018-07-21 10:10:00',
                duration='2:30:00',
                longitude=123.4567890123456789,
                latitude=37.0000056,
                location='无名路18号',
                a_type='演讲',
                reservation='个人预约',
                introduction="MySQL中定义数据字段的类型对你数据库的优化是\n非常重要的。",
            })
            if not res then
                ngx.say('insert error: ', err)
                return
            else
                ngx.say('add user!', err)
            end
            local res = conn:rmv_activity({
                a_id=8,
            })
            if not res then
                ngx.say('remove error: ', err)
                return
            else
                ngx.say('remove user 2!', err)
            end

                local res, err, errcode, sqlstate =
                    conn:next_week_activity({n=3})
                if not res then
                    ngx.say("bad result: ", err, ": ", errcode, ": ", sqlstate, ".")
                    return
                end

                local cjson = require "cjson"
                ngx.say("result: ", cjson.encode(res))

            local res = conn:spare_conn()
            if not res then
                ngx.say('spare error: ', err)
                return
            else
                ngx.say('spare ok!', err)
            end
        }
    }
    location /mysql_json {
        charset utf-8;
        default_type application/json;
        content_by_lua_block {
            local dbact = require("cclua.activity")
            local conn, err = dbact:new('get')
            if not conn then
                resp = {status=false, err=err}
            else
                local res, err, errcode, sqlstate = conn:next_week_activity()
                if not res then
                    resp = {status=false, err=err, errcode=errcode}
                else
                    resp = {status=true, result=res}
                end
            end
            local cjson = require "cjson"
            ngx.status = ngx.HTTP_OK  
            ngx.say(cjson.encode(resp))
            return ngx.exit(ngx.HTTP_OK)  
        }
    }
    location /test_post {
        default_type 'text/plain';
        content_by_lua_block {
            ngx.req.read_body()
            local args, err = ngx.req.get_post_args()
            local resp = {}

            if err == "truncated" then
                -- one can choose to ignore or reject the current request here
                resp = {err=err}
            end
            if not args then
                resp = {err="failed to get post args: " .. err}
            else
                resp = {err=0, args=args}
            end
            local cjson = require "cjson"
            ngx.status = ngx.HTTP_OK  
            ngx.say(cjson.encode(resp))
            ngx.log(ngx.ERR,cjson.encode(resp))
            return ngx.exit(ngx.HTTP_OK)
        }
    }
    location /test_pass {
        default_type 'text/plain';
        content_by_lua_block {
            ngx.say('123456')
        }
    }
}
